# Процессы в Linux и Unix
Процесс - это такая абстракция на уровне ядра и фаловой системы, которая позволяет описывать запущенные программы в данный момент времени. У процесса есть такие атрибуты, как:
1. ID процесса - PID
2. ID родительского процесса - PPID
3. Фактор уступчивости - количественная характеристика, которая показывает насколько процесс будет уступать другим в использовании ресурсов. Можно поменять командами **nice** и **renice**
4. Статус процесса - выполняется, неактивен, приостановлен, зомби и пр.
5. Имя пользователя, от имени которого запущен процесс.
6. Непосредственно команда или имя потока
7. Идентификатор управляющего терминала

По порядку. Каждый процесс является дочерним. На этапе загрузки системы ядро запускает демон **init\systemd**, который уже является родительским для всех запускаемых им процессов(очевидно). Системный демон всегда имеет **ID** процесса равное единице. Если взглянуть на родительский идентификатор **systemd**, то можно увидеть, что значение выставленно в ноль. В данном контексте ноль означает ядро, которые по сути и является родительским "процессом" **systemd**. Помимо системного демона, ядро также запускает различные потоки, в которые пока не стоит вдаваться детально.

В стандарте **POSIX** не существует системного вызова для непосредственного создания процесса. Вместо этого используется вызов **fork**, который, как понятно из названия, клонирует себя и передает управление клона запускаемой программе. Процесс, который клонировал себя является родительским, а клон - дочерним. После системного вызова **fork** дочерний процесс запускает новую программу с помоющью одного из системных вызовов **exec**. 

##### Управляющий терминал. Процессы-зомби, syscall wait
Управляющий терминал - такой родительский процесс, через который порождаются и умирают процессы, не являющиеся демонами и пр. Определенный процесс также может отсоединиться от своего управляющего терминала, вызвав setsid. Процессы, который завершили свою работу, но не подтвердили свою "смерть" у управляющего терминала\родительского процесса - называются процессами-зомби (так как они "мертвы", но не погребены). Дочерний процесс вызывает системный вызов wait, который делает запрос к управляющему терминалу. 

##### Сигналы процессов. команда kill
В \*nix системах для взаимодействия с процессами, помимо сокетов, существуют сигналы. Сигналы являются индикаторами, которые "говорят" процессам следующее:
1. *SIGKILL* - безжалостно убивает процесс
2. *SIGTERM* - запрашивает завершение процесса у управляющего терминала
3. *SIGSTOP* - останавливает процесс
4. *SIGCONT* - возобновляет процесс
Некоторые сигналы можно блокировать и перехватывать. Например KILL, STOP и *CONT* не блокируются. В целом , сигналы предназначены для двух вещей - остановка и отключение процесса(ну и сигнал CONT, который снимает процесс с паузы). Чтобы послатьа сигнал процессу из терминала существует команда kill. Сигналом по умолчанию в данной команде является SIGTERM. 

##### Файловая система procfs и команда top
Есть такая прекрасная команда-программа, как **top**(или ее более совершенный потомок **htop**). Она выполняет похожую с ps функцию: по сути это dashboard обо всех загруженных процессах. Программа **top** читает **/proс** и выводит информацию, основываясь на существующих там файлах и директориях. Сама по себе файловая система procfs является стандартной для Unix-подобных систем. Она состоит из двух уровней:
1. На верхнем уровне содержаться каталоги с процессами, именованные в соотвествие с PID. 
2. И соответственно то, что и определяет процесс: переменные окружения, команда запущенного процесса, различные символические ссылки(на открытые файлы, корень и прочее).

##### Периодические процессы. Cron и таймеры systemd
Для таких рутинных действий, как отправка почты, очитстка **/tmp**, создание бэкапа и пр. существует полезный демон **cron**. Cron очень прост в использовании и настраивается через файл конфигурации **crontab**. Конфиг содержит информацию о дате и времени запуска, команду, которую нужно запустить и переменные окружения. Как и все демоны, загружается от **systemd**. Файл **crontab** различен для всех пользователей. Помимо данного демона есть другая возможность автоматизации запуска периодических процессов - таймеры **systemd**. По сути, это те же **units**, только с параметром запуска, который содержит количество секунд, прошедшее после определенного события:
- *OnBootSec* - запуск системы
- *OnActiveSec* - запуск таймера
- *OnStartupSec* - запуск системы
- *OnCalendar* - конкретное время, не зависящее от события
Помимо файла таймера, нужно также создать файл запускаемого сервиса. Запускаемый **unit** можно конкретно назначить в файле тамера в параметре **Unit**. Но, **systemd** и сам может найти сервис по одноименному названию таймера (например, **clear_tmpfs.timer** и **clear_tmpfs.service**).